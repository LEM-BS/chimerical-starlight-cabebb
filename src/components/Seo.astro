---
type RobotsDirectives = string[] | { index?: boolean; follow?: boolean; advanced?: string[] };
type BreadcrumbEntry = { name: string; item?: string; path?: string };
type AlternateLink = { rel?: string; href: string; hreflang?: string };
type AdditionalMetaTag = { name?: string; property?: string; content: string; [key: string]: string | undefined };

export interface Props {
  title?: string;
  description?: string;
  canonical?: string;
  canonicalPath?: string;
  titleSuffix?: string;
  fullTitle?: boolean;
  robots?: RobotsDirectives;
  openGraph?: Record<string, string>;
  twitter?: Record<string, string>;
  structuredData?: Record<string, unknown>[];
  breadcrumbs?: BreadcrumbEntry[];
  alternates?: AlternateLink[];
  locale?: string;
  siteName?: string;
  image?: string;
  additionalMeta?: AdditionalMetaTag[];
}

const {
  title,
  description = '',
  canonical,
  canonicalPath,
  titleSuffix = ' | LEM Building Surveying',
  fullTitle = false,
  robots = {},
  openGraph = {},
  twitter = {},
  structuredData = [],
  breadcrumbs = [],
  alternates = [],
  locale = 'en_GB',
  siteName = 'LEM Building Surveying',
  image = 'https://lembuildingsurveying.co.uk/logo-sticker.png',
  additionalMeta = [],
} = Astro.props as Props;

const clamp = (value: string, limit = 60) => {
  if (!value) return '';
  return value.length <= limit ? value : `${value.slice(0, limit - 1).trim()}â€¦`;
};

const defaultTitle = 'LEM Building Surveying | Professional Surveyors';

const site = Astro.site ?? new URL('https://lembuildingsurveying.co.uk');

const stripHtmlExtension = (pathname: string = '/') => {
  if (!pathname) return '/';
  let normalized = pathname;
  if (!normalized.startsWith('/') && !/^https?:\/\//i.test(normalized) && !normalized.startsWith('//')) {
    normalized = `/${normalized}`;
  }
  if (/^https?:\/\//i.test(normalized) || normalized.startsWith('//')) {
    const resolved = new URL(normalized, site);
    normalized = resolved.pathname;
  }
  if (normalized.toLowerCase().endsWith('/index.html')) {
    normalized = normalized.slice(0, -'/index.html'.length);
  } else if (normalized.toLowerCase().endsWith('.html')) {
    normalized = normalized.slice(0, -'.html'.length);
  }
  if (normalized.length > 1 && normalized.endsWith('/')) {
    normalized = normalized.replace(/\/+$/g, '');
  }
  return normalized || '/';
};

const toAbsoluteUrl = (value: string) => {
  const trimmed = value.trim();
  if (!trimmed) {
    return site.toString();
  }
  let url: URL;
  if (/^https?:\/\//i.test(trimmed)) {
    url = new URL(trimmed);
  } else if (trimmed.startsWith('//')) {
    url = new URL(`https:${trimmed}`);
  } else {
    const relative = trimmed.startsWith('/') ? trimmed : `/${trimmed}`;
    url = new URL(relative, site);
  }
  url.pathname = stripHtmlExtension(url.pathname || '/');
  if (url.pathname.length > 1 && url.pathname.endsWith('/')) {
    url.pathname = url.pathname.replace(/\/+$/g, '');
  }
  if (!url.pathname) {
    url.pathname = '/';
  }
  return url.toString();
};

const fallbackPath = canonicalPath ?? Astro.url.pathname ?? '/';
const normalizedPath = stripHtmlExtension(fallbackPath);

let canonicalUrl = canonical ? toAbsoluteUrl(canonical) : toAbsoluteUrl(normalizedPath);
const canonicalPathFromUrl = stripHtmlExtension(new URL(canonicalUrl).pathname || '/');

const resolveBreadcrumbHref = (entry: BreadcrumbEntry) => {
  if (entry.item) return entry.item;
  if (!entry.path) return new URL('#', site).toString();
  const normalized = stripHtmlExtension(entry.path);
  return new URL(normalized, site).toString();
};

const normalizedTitle = (title ?? '').trim();
const hasCustomTitle = normalizedTitle.length > 0;
const computedTitle = hasCustomTitle
  ? fullTitle
    ? clamp(normalizedTitle)
    : clamp(`${normalizedTitle}${titleSuffix}`.trim())
  : defaultTitle;

const robotsConfig = robots as RobotsDirectives;
const robotsDirectives: string[] = Array.isArray(robotsConfig)
  ? (robotsConfig as string[])
  : [
      robotsConfig?.index === false ? 'noindex' : 'index',
      robotsConfig?.follow === false ? 'nofollow' : 'follow',
      ...((robotsConfig && 'advanced' in robotsConfig && robotsConfig.advanced) || []),
    ];

const ogTitle = openGraph.title ?? computedTitle;
const ogDescription = openGraph.description ?? description;
const ogType = openGraph.type ?? 'website';
const ogImage = openGraph.image ?? image;
const ogUrl = openGraph.url
  ? toAbsoluteUrl(openGraph.url)
  : new URL(canonicalPathFromUrl, site).toString();

const twitterCard = twitter.card ?? 'summary_large_image';
const twitterTitle = twitter.title ?? computedTitle;
const twitterDescription = twitter.description ?? description;
const twitterImage = twitter.image ?? ogImage;

const structuredDataBlocks: Record<string, unknown>[] = [...structuredData];
const breadcrumbItems = [...breadcrumbs];
if (breadcrumbItems.length > 0) {
  structuredDataBlocks.push({
    '@context': 'https://schema.org',
    '@type': 'BreadcrumbList',
    itemListElement: breadcrumbItems.map((item: BreadcrumbEntry, index: number) => ({
      '@type': 'ListItem',
      position: index + 1,
      name: item.name,
      item: resolveBreadcrumbHref(item),
    })),
  });
}
const alternateLinks = [...alternates];
const metaEntries = [...additionalMeta];
---

{computedTitle && <title>{computedTitle}</title>}
{description && <meta name="description" content={description} />}
<link rel="canonical" href={canonicalUrl} />
{robotsDirectives.length > 0 && (
  <meta name="robots" content={robotsDirectives.join(', ')} />
)}
<meta property="og:type" content={ogType} />
{ogTitle && <meta property="og:title" content={ogTitle} />}
{ogDescription && <meta property="og:description" content={ogDescription} />}
<meta property="og:url" content={ogUrl} />
{siteName && <meta property="og:site_name" content={siteName} />}
{ogImage && <meta property="og:image" content={ogImage} />}
<meta name="twitter:card" content={twitterCard} />
{twitterTitle && <meta name="twitter:title" content={twitterTitle} />}
{twitterDescription && (
  <meta name="twitter:description" content={twitterDescription} />
)}
{twitterImage && <meta name="twitter:image" content={twitterImage} />}
{alternateLinks.map((alternate: AlternateLink) => (
  <link
    rel={alternate.rel ?? 'alternate'}
    href={alternate.href}
    hreflang={alternate.hreflang}
  />
))}
{locale && <meta property="og:locale" content={locale} />}
{metaEntries.map((meta: AdditionalMetaTag) => (
  <meta {...meta} />
))}
{structuredDataBlocks.map((schema) => (
  <script
    type="application/ld+json"
    is:inline
    set:html={JSON.stringify(schema)}
  ></script>
))}
